//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
namespace AssemblyCSharp{
	public class main : MonoBehaviour {
		public GameObject Boid;
		public GameObject Predator;
		public List<GameObject> Boids;
		public List<GameObject> Predators;
		int numbBoids =50;
		int numbPreds = 1;
		public float dt = 0.00005f;
		const float kCohesion = -0.001f;
		const float kSeperation = 0.0001f;
		const float kAlignment = -0.01f;
		
		public void Start(){
			Boids = new List<GameObject>();
			Predators = new List<GameObject>();
			
			for(int i=0;i<numbBoids;i++){
				GameObject boid = (GameObject)Instantiate(Boid);
				boid.name = "boid"+i;
				float rand1 = (float)GetRandomNumber (-2.0,2.0);
				float rand2 = (float)GetRandomNumber (-2.0,2.0);
				float rand3 = (float)GetRandomNumber (-2.0,2.0);
				boid.transform.position = new Vector3(rand1, 0f, rand3);
				
				Boid b = boid.GetComponent<Boid>();
				rand1 = (float)GetRandomNumber (-.1,.1);
				rand2 = (float)GetRandomNumber (-.1,.1);
				rand3 = (float)GetRandomNumber (-.1,.1);
				b.velocity = new Vector3(rand1,0f,rand3);
				
				Boids.Add (boid);
			}
			for(int i =0;i<numbPreds;i++){
				GameObject pred = (GameObject)Instantiate (Predator);
				pred.name = "pred"+i;
				pred.transform.position = new Vector3(-5f,0f,-5f);
				Predator p = pred.GetComponent<Predator>();
				p.velocity = new Vector3(0.08f,0.0f,0.08f);
				Predators.Add(pred);
			}
		}
		
		static System.Random random = new System.Random();
		public double GetRandomNumber(double minimum, double maximum){ 
			return random.NextDouble() * (maximum - minimum) + minimum;
		}
		
		public Vector3 cohesion(Boid boid){
			/*		List<Vector3> positions = new List<Vector3> ();
			Vector3 thisPosition = boid.transform.position;
			Vector3 predPosition = Predator.transform.position;
			foreach (GameObject b in Boids) {
				Boid boids = b.GetComponent<Boid>();
				if (boids != boid)
					positions.Add (b.transform.position);
			}
			// positions now contain all positions of other boids
			Vector3 sumPosition = new Vector3 (0.0f, 0.0f, 0.0f);
			foreach (Vector3 position in positions) {
				sumPosition = sumPosition + position;
			}
			Vector3 positionCm = sumPosition / (Boids.Count-1);
			Vector3 distance = thisPosition - positionCm;
			Vector3 accel = new Vector3 (0.0f, 0.0f, 0.0f);

			float kCohesion2 = -0.001f;
			if(distance.sqrMagnitude > 3){//&&(predPosition - thisPosition).magnitude >5){//if distance between boid and com is more then 3
				accel = kCohesion*(distance / distance.sqrMagnitude) + kCohesion2*(distance / distance.magnitude);
			}
			else 
				accel = Vector3.zero;

			return accel;*/
			Vector3 accel = new Vector3();
			int count =0;
			float k = 0.001f;
			foreach (GameObject b in Boids) {
				float dist = Vector3.Distance(boid.transform.position,b.transform.position);
				if(dist < .3 && dist > 0){
					accel = accel + b.transform.position;
					count++;
				}
				if(count > 0){
					accel = accel / count;
					return accel-boid.transform.position;
				}
			}
			return k*accel;
		}
		public Vector3 seperation(Boid boid){
			List<Vector3> positions = new List<Vector3> ();
			Vector3 thisPosition = boid.transform.position;
			
			foreach (GameObject b in Boids) {
				Boid boids = b.GetComponent<Boid>();
				if (boids != boid)
					positions.Add (b.transform.position);
			}
			// positions now contain all positions of other boids
			List<Vector3> accelIs = new List<Vector3> ();
			foreach (Vector3 position in positions) {
				Vector3 distanceI = thisPosition - position;
				if(distanceI.magnitude < 5){//if distance between boids is less then 2
					Vector3 accelI = distanceI / distanceI.sqrMagnitude;
					accelIs.Add (accelI);
				}
				
			}
			// accelIs now contain all pseudo-separation-accelerations (not
			// multiplied with the constant) due to each of the other boids
			Vector3 sumAccelI = new Vector3 (0.0f, 0.0f, 0.0f);
			foreach (Vector3 accelI in accelIs) {
				sumAccelI = sumAccelI + accelI;
			}
			
			return kSeperation * sumAccelI;
			
			/*Vector3 acceleration = new Vector3();
			int count =0;
			float k = 1f;
			foreach (GameObject b in Boids) {
				float dist = Vector3.Distance(boid.transform.position,b.transform.position);
				if(dist < 2 && dist > 0){
					acceleration = acceleration + (boid.transform.position - b.transform.position).normalized / dist;
					count++;
				}
				if(count > 0){
					acceleration = acceleration / count;
				}
			}
			return k*acceleration;*/
		}
		public Vector3 allignment(Boid boid){
			/*List<Vector3> velocities = new List<Vector3> ();
			Vector3 thisVelocity = boid.velocity;
			foreach (GameObject b in Boids) {
				Boid boids = b.GetComponent<Boid>();
				
				if (boids != boid)
					velocities.Add (boids.velocity);
			}
			// positions now contain all positions of other boids
			Vector3 sumVelocities = new Vector3 (0.0f, 0.0f, 0.0f);
			foreach (Vector3 velocity in velocities) {
				sumVelocities = sumVelocities + velocity;
			}
			Vector3 velocityCm = sumVelocities / (Boids.Count-1);
			Vector3 distance = thisVelocity - velocityCm;
			Vector3 accel = new Vector3 (0.0f, 0.0f, 0.0f);

			accel = kAlignment * distance;

			//Vector3 accel = distance / 100;
			return accel;*/
			
			Vector3 accel = new Vector3();
			int count =0;
			float k = 0.08f;
			foreach (GameObject b in Boids) {
				float dist = Vector3.Distance(boid.transform.position,b.transform.position);
				if(dist < 30 && dist > 0){
					Boid boids = b.GetComponent<Boid>();
					accel = accel + boids.velocity;
					count++;
				}
			}
			if(count > 0){
				accel = accel / count;
				accel = Vector3.ClampMagnitude(accel, 1);
			}
			
			return k*accel;
		}
		
		public void limitVel(Boid boid){
			float vlim = .05f;
			Vector3 vel = new Vector3 (0.0f, 0.0f, 0.0f);
			if(boid.velocity.magnitude > vlim){
				boid.velocity = (boid.velocity / boid.velocity.magnitude) * vlim;
			}
		}
		
		public void limitVelPred(Predator pred){
			float vlim = .02f;
			Vector3 vel = new Vector3 (0.0f, 0.0f, 0.0f);
			if(pred.velocity.magnitude > vlim){
				pred.velocity = (pred.velocity / pred.velocity.magnitude) * vlim;
			}
		}
		
		public Vector3 limitPos(Boid boid){
			int xmin = -10;
			int xmax = 10;
			int ymin = -10; 
			int ymax = 10;
			int zmin = -10;
			int zmax = 10;
			Vector3 vel = new Vector3 (0.0f, 0.0f, 0.0f);
			
			if(boid.transform.position.x < xmin){
				vel.x = 0.002f;
			}
			else if (boid.transform.position.x > xmax){
				vel.x = -0.002f;
			}
			if(boid.transform.position.y < ymin){
				vel.y = 0.002f;
			}
			else if (boid.transform.position.y > ymax){
				vel.y = -0.002f;
			}
			if(boid.transform.position.z < zmin){
				vel.z = 0.002f;
			}
			else if (boid.transform.position.z > zmax){
				vel.z = -0.002f;
			}
			
			return vel;
		}
		
		float t =0.0f;
		float speed = (2*Mathf.PI)/200.0f;
		float radius = 100.0f;
		public Vector3 attraction(Boid boid){
			t += speed*Time.deltaTime;
			Vector3 loc = new Vector3 ((float)Math.Cos (t)*radius, 0.0f, (float)Math.Sin (t)*radius);
			
			return (Predator.transform.position - boid.transform.position).normalized;
		}
		
		public Vector3 chasePrey(Predator predator){
			Vector3 accel = new Vector3();
			int count =0;
			float k = 0.001f;
			foreach (GameObject b in Boids) {
				float dist = Vector3.Distance(predator.transform.position,b.transform.position);
				if(dist < .3 && dist > 0){
					accel = accel + b.transform.position;
					count++;
				}
				if(count > 0){
					accel = accel / count;
					return (accel - predator.transform.position).normalized;
				}
			}
			return (k*accel).normalized;
		}
		
		int k1 =1;
		int k2 =1;
		int k3 =1;
		int k4 =20;
		int k5 =1;
		public void Update(){
			foreach(GameObject b in Boids){
				Boid boid = b.GetComponent<Boid>();
				
				Vector3 a4 = new Vector3();
				if((b.transform.position - Predator.transform.position).magnitude<.08){
					k1 = -1;
					a4 = -k4*attraction(boid);
				}
				else{
					k1 = 1;
					a4 = Vector3.zero;
				}
				Vector3 a1=k1*cohesion(boid);
				Vector3 a2=k2*seperation(boid);
				Vector3 a3=k3*allignment(boid);
				//				Vector3 a4=k4*attraction(boid);
				Vector3 a5=k5*limitPos(boid);
				boid.velocity = boid.velocity + a1*dt + a2*dt + a3*dt +a4*dt+ a5*dt;// + a4*dt+ a5*dt;
				float rand1 = (float)GetRandomNumber (-.01,.01);
				float rand2 = (float)GetRandomNumber (-.01,.01);
				float rand3 = (float)GetRandomNumber (-.01,.01);
				boid.velocity.x = boid.velocity.x + rand1;
				//boid.velocity.y = boid.velocity.y + rand2;
				boid.velocity.z = boid.velocity.z + rand3;
				limitVel(boid);
				boid.move();
			}
			foreach(GameObject p in Predators){
				Predator predator = p.GetComponent<Predator>();
				predator.velocity = predator.velocity + chasePrey(predator);
				limitVelPred (predator);
				predator.move();
			}
		}
	}
}

